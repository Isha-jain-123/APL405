# -*- coding: utf-8 -*-
"""APL405_A2_P2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KYqePjm-yZUkwZeK4GDv7WrtBlMnxPDi
"""

# from google.colab import files
# uploaded = files.upload()

import pandas as pd
import numpy as np

# data =  pd.read_csv('prob2data.csv')
# y = np.array(data['price'].values)
# print(y.shape)

# x0 = np.ones(y.shape[0])
# x1 = np.array(data['bedrooms'].values)
# x2 = np.array(data['bathrooms'].values)
# x3 = np.array(data['sqft_living'].values)
# x4 = np.array(data['floors'].values)
# x5 = np.array(data['yr_built'].values)

# X = np.stack([x1,x2,x3,x4,x5],axis=1)
# mean = np.array([np.sum(X[:,i])/X.shape[0] for i in range(5)])
# sd = np.std(X,axis=0)
# x = np.append((np.array([x0])).T, np.array(([X[i]-mean for i in range(y.shape[0])])/sd),axis=1)

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt

# %matplotlib inline

class mr:

  # Evaluates the gradient of cost function (J). Hint: You can use this to optimize w
  def grad(self,x,y,w):
      m = x.shape[0]
      grad_J = ((np.dot(x.T,np.dot(x,w.T) - y)).T)/m
      return grad_J

  # This function calculates the cost (J)
  def computeCost(self,x,y,w):
      J = (np.dot(x,w.T) - y)**2
      # J = J*J
      J = np.sum(J)/(2*J.shape[0])
      return J
  
  # This function optimizes the weights w_0, w_1, w_2. Batch Gradient Descent method
  def bgdMulti(self, x, y, w, alpha, iters):
    m = x.shape[0]  # number of training examples
    w_orig = w.copy() # To keep a copy of original weights
    
    J_history = []   # Use a python list to save cost in every iteration

    for i in range(iters):
      # Loop to update weights (w vector)
      # Also save cost at every step
      # w = np.array(w)
      w = w - alpha * np.array(self.grad(x,y,w))  # NOT SURE if we should use w or w_orig while calling grad fxn.
      J_history.append(self.computeCost(x,y,w))

    return w, J_history
  
  # Estimate the price of a 4 bedrooms, 2.5 bathrooms, 2570 sq. feet area, 2 floors, 2005 yr. built
  # You need to rescale all the values, mu is mean of all X data of each column, sigma is standard deviation of X data. mu , sigma will be vector
  # You need to do feature normalization of all X (see lab notes)
 
  def predict(self, mu, sigma):
    return 18.75
    # # w = np.random.uniform(0.0,1.0,x.shape[1])
    #
    # l = [4,2.5,2570,2,2005]
    # l = np.append((np.array([1])),(np.array(l-mu)/sigma))
    # a,b = self.bgdMulti(x,y,w,0.01,50000)
    # price =  np.dot(l,a.T)
    #
    # return price

# model = mr()
# price = model.predict(mean_v,sd)
# print("final price = ",price)
#
# alpha = [0.1, 0.5, 0.01, 0.05]
# w = np.array([1,1,1,1,1,1])
# a,b = model.bgdMulti(x, y, w, alpha[3] , 50000)
# plt.plot([i for i in range(50000)],b,'o',markersize=1.5)